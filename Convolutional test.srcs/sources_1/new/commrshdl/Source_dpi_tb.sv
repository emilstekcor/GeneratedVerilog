// -------------------------------------------------------------
// 
// File Name: C:\Users\kyle\Desktop\Convolutional test\Convolutional test.srcs\sources_1\new\commrshdl\Source_dpi_tb.sv
// Created: 2024-04-11 05:13:47
// 
// Generated by MATLAB 23.2, HDL Coder 23.2, and Simulink 23.2
// 
// 
// -- -------------------------------------------------------------
// -- Rate and Clocking Details
// -- -------------------------------------------------------------
// Model base rate: 42
// Target subsystem base rate: 42
// 
// -------------------------------------------------------------


// -------------------------------------------------------------
// 
// Module: Source_dpi_tb
// Source Path: 
// Hierarchy Level: 0
// 
// -------------------------------------------------------------

`timescale 1 ns / 1 ns

module Source_dpi_tb;

  logic clk;
  logic reset_x;
  logic enb;
  logic const_true;
  logic snkDone;
  logic const_false;
  logic dutEnable;
  logic signed [3:0] DataOut;  /* sfix4_E14 */
  logic start;
  logic end_rsvd;
  logic valid;
  logic ce_out;
  logic dpiReset;
  logic dpiEnable;
  logic dpiEnbDelay;
  logic signed [7:0] dpi_1;  /* sfix8_E14 */
  logic [7:0] dpi_2;  /* ufix8 */
  logic [7:0] dpi_3;  /* ufix8 */
  logic [7:0] dpi_4;  /* ufix8 */
  logic [3:0] dpi_1_temp;  /* ufix4 */
  logic signed [3:0] DataOut_ref;  /* sfix4_E14 */
  logic DataOut_testFailure;
  logic dpi_2_temp;
  logic start_ref;
  logic start_testFailure;
  logic dpi_3_temp;
  logic end_rsvd_ref;
  logic end_rsvd_testFailure;
  logic dpi_4_temp;
  logic valid_ref;
  logic valid_testFailure;
  logic isTestFailed;

  function isFloatDoubleEpsVecEqual;
  input [63:0] x [];
  input [63:0] y [];
  input real eps;

  logic retVal;
  retVal = 1;
  for(int j=0; j < x.size; j++) begin
    retVal = retVal && isFloatDoubleEpsEqual(x[j],y[j],eps);
  end
  return retVal;
endfunction
function isFloatDoubleEps2DMacEqual;
input [63:0] x [][];
input [63:0] y [][];
input real eps;

logic retVal;
retVal = 1;
foreach(x[i,j])
  retVal = retVal && isFloatDoubleEpsEqual(x[i][j],y[i][j],eps);
  return retVal;
endfunction
function isFloatDoubleEps3DMacEqual;
input [63:0] x [][][];
input [63:0] y [][][];
input real eps;

logic retVal;
retVal = 1;
foreach(x[i,j,k])
  retVal = retVal && isFloatDoubleEpsEqual(x[i][j][k],y[i][j][k],eps);
  return retVal;
endfunction
function isFloatSingleEpsVecEqual;
input [31:0] x [];
input [31:0] y [];
input real eps;

logic retVal;
retVal = 1;
for(int j=0; j < x.size; j++) begin
  retVal = retVal && isFloatSingleEpsEqual(x[j],y[j],eps);
end
return retVal;
endfunction
function isFloatSingleEps2DMacEqual;
input [31:0] x [][];
input [31:0] y [][];
input real eps;

logic retVal;
retVal = 1;
foreach(x[i,j])
  retVal = retVal && isFloatSingleEpsEqual(x[i][j],y[i][j],eps);
  return retVal;
endfunction
function isFloatSingleEps3DMacEqual;
input [31:0] x [][][];
input [31:0] y [][][];
input real eps;

logic retVal;
retVal = 1;
foreach(x[i,j,k])
  retVal = retVal && isFloatSingleEpsEqual(x[i][j][k],y[i][j][k],eps);
  return retVal;
endfunction
function isFloatHalfEpsVecEqual;
input [15:0] x [];
input [15:0] y [];
input real eps;

logic retVal;
retVal = 1;
for(int j=0; j < x.size; j++) begin
  retVal = retVal && isFloatHalfEpsEqual(x[j],y[j],eps);
end
return retVal;
endfunction
function isFloatHalfEps2DMacEqual;
input [15:0] x [][];
input [15:0] y [][];
input real eps;

logic retVal;
retVal = 1;
foreach(x[i,j])
  retVal = retVal && isFloatHalfEpsEqual(x[i][j],y[i][j],eps);
  return retVal;
endfunction
function isFloatHalfEps3DMacEqual;
input [15:0] x [][][];
input [15:0] y [][][];
input real eps;

logic retVal;
retVal = 1;
foreach(x[i,j,k])
  retVal = retVal && isFloatHalfEpsEqual(x[i][j][k],y[i][j][k],eps);
  return retVal;
endfunction
function real absReal(input real num);
begin
  if (num < 0)
    absReal = -num;
  else
    absReal = num;
end
endfunction

function real floatHalfToReal;
input [15:0] x;
reg [63:0] conv;

begin
  conv[63] = x[15]; // sign 
  if (x[14:10] == 5'b0) // exp 
    conv[62:52] = 11'b0; 
  else
    conv[62:52] = 1023 + (x[14:10] - 15);
  conv[51:42] = x[9:0]; // mantissa 
  conv[41:0] = 42'b0;
  if (((x[14:10] == 5'h1F) && (x[9:0] != 10'h0))) // check for NaN 
  begin
    conv[63] = 1'b0;
    conv[62:52] = 11'h7FF;
    conv[51:0] = 52'h0;
  end
  floatHalfToReal = $bitstoreal(conv);
end
endfunction

function real floatSingleToReal;
input [31:0] x;
reg [63:0] conv;

begin
  conv[63] = x[31]; // sign 
  if (x[30:23] == 8'b0) // exp 
    conv[62:52] = 11'b0; 
  else
    conv[62:52] = 1023 + (x[30:23] - 127);
  conv[51:29] = x[22:0]; // mantissa 
  conv[28:0] = 29'b0;
  if (((x[30:23] == 8'hFF) && (x[22:0] != 23'h0))) // check for NaN 
  begin
    conv[63] = 1'b0;
    conv[62:52] = 11'h7FF;
    conv[51:0] = 52'h0;
  end
  floatSingleToReal = $bitstoreal(conv);
end
endfunction

function real floatDoubleToReal;
input [63:0] x;
reg [63:0] conv;

begin
  conv[63:0] = x[63:0]; 
  if (((x[62:52] == 11'h7FF) && (x[51:0] != 52'h0))) // check for NaN 
  begin
    conv[63] = 1'b0;
    conv[62:52] = 11'h7FF;
    conv[51:0] = 52'h0;
  end
  floatDoubleToReal = $bitstoreal(conv);
end
endfunction

function isFloatEpsEqual(input real a, input real b, input real eps);
real absdiff;

begin
  absdiff = absReal(a - b);
  if (absdiff < eps) // absolute error check 
    isFloatEpsEqual = 1;
  else if (a == b) // check infinities 
    isFloatEpsEqual = 1; 
  else if (a*b == 0.0) // either is zero 
    isFloatEpsEqual = (absdiff < eps);
  else if (absReal(a) < absReal(b)) // relative error check
    isFloatEpsEqual = absdiff/absReal(b) < eps;
  else
    isFloatEpsEqual = absdiff/absReal(a) < eps;
end
endfunction
function isFloatHalfEpsEqual;
input [15:0] x;
input [15:0] y;
input real eps;
real a, b;
real absdiff;

begin
  a = floatHalfToReal(x);
  b = floatHalfToReal(y);
  isFloatHalfEpsEqual = isFloatEpsEqual(a, b, eps);
end
endfunction
function isFloatSingleEpsEqual;
input [31:0] x;
input [31:0] y;
input real eps;
real a, b;
real absdiff;

begin
  a = floatSingleToReal(x);
  b = floatSingleToReal(y);
  isFloatSingleEpsEqual = isFloatEpsEqual(a, b, eps);
end
endfunction
function isFloatDoubleEpsEqual;
input [63:0] x;
input [63:0] y;
input real eps;
real a, b;
real absdiff;

begin
  a = floatDoubleToReal(x);
  b = floatDoubleToReal(y);
  isFloatDoubleEpsEqual = isFloatEpsEqual(a, b, eps);
end
endfunction

  assign const_true = 1'b1;



assign #520 snkDone = const_true;

always 
  begin : clk_gen
    clk <= 1'b1;
    # (5);
    clk <= 1'b0;
    # (5);
    if (snkDone == 1'b1) begin
      clk <= 1'b1;
      # (5);
      clk <= 1'b0;
      # (5);
      $stop;
    end
  end

initial
  begin : reset_x_gen
    reset_x <= 1'b1;
    # (30);
    @ (posedge clk)
    # (2);
    reset_x <= 1'b0;
  end

  assign const_false = 1'b0;



  assign enb = (reset_x == 1'b0 ? const_true :
              const_false);



// Delay inside enable generation: register depth 
always @(posedge clk)
  begin : dut_enable_delay
    if (reset_x) begin
      dutEnable <= 0;
    end
    else begin
      dutEnable <= enb;
    end
  end

Source u_Source (.clk(clk),
                 .reset_x(reset_x),
                 .clk_enable(dutEnable),
                 .DataOut(DataOut),  /* sfix4_E14 */
                 .start(start),
                 .end_rsvd(end_rsvd),
                 .valid(valid),
                 .ce_out(ce_out)
                 );

initial
  begin : dpiReset_gen
    dpiReset <= 1'b1;
    # (20);
    @ (posedge clk)
    # (2);
    dpiReset <= 1'b0;
  end

  assign dpiEnable = (dpiReset == 1'b0 ? const_true :
              const_false);



// Delay inside enable generation: register depth 
always @(posedge clk)
  begin : dut_enable_delay_1
    if (dpiReset) begin
      dpiEnbDelay <= 0;
    end
    else begin
      dpiEnbDelay <= dpiEnable;
    end
  end

gm_commrshdl_ref_dpi #(.loop_factor(1),
                       .overclocking_factor(1)
                       )
                     u_gm_commrshdl_ref_dpi (.clk(clk),
                                             .reset(dpiReset),
                                             .clk_enable(dpiEnbDelay),
                                             .dpi_1(dpi_1),  /* sfix8_E14 */
                                             .dpi_2(dpi_2),  /* ufix8 */
                                             .dpi_3(dpi_3),  /* ufix8 */
                                             .dpi_4(dpi_4)  /* ufix8 */
                                             );

  assign dpi_1_temp = dpi_1[3:0];



  assign DataOut_ref = dpi_1_temp;



always @(posedge clk)
  begin : DataOut_checker
    if (reset_x == 1'b1) begin
      DataOut_testFailure <= 1'b0;
    end
    else begin
      if (dutEnable == 1'b1 && DataOut !== DataOut_ref) begin
        DataOut_testFailure <= 1'b1;
        $display("ERROR in DataOut at time %t : Expected '%h' Actual '%h'", $time, DataOut_ref, DataOut);
      end
    end
  end

  assign dpi_2_temp = dpi_2[0];



assign start_ref = dpi_2_temp;

always @(posedge clk)
  begin : start_checker
    if (reset_x == 1'b1) begin
      start_testFailure <= 1'b0;
    end
    else begin
      if (dutEnable == 1'b1 && start !== start_ref) begin
        start_testFailure <= 1'b1;
        $display("ERROR in start at time %t : Expected '%h' Actual '%h'", $time, start_ref, start);
      end
    end
  end

  assign dpi_3_temp = dpi_3[0];



assign end_rsvd_ref = dpi_3_temp;

always @(posedge clk)
  begin : end_rsvd_checker
    if (reset_x == 1'b1) begin
      end_rsvd_testFailure <= 1'b0;
    end
    else begin
      if (dutEnable == 1'b1 && end_rsvd !== end_rsvd_ref) begin
        end_rsvd_testFailure <= 1'b1;
        $display("ERROR in end_rsvd at time %t : Expected '%h' Actual '%h'", $time, end_rsvd_ref, end_rsvd);
      end
    end
  end

  assign dpi_4_temp = dpi_4[0];



assign valid_ref = dpi_4_temp;

always @(posedge clk)
  begin : valid_checker
    if (reset_x == 1'b1) begin
      valid_testFailure <= 1'b0;
    end
    else begin
      if (dutEnable == 1'b1 && valid !== valid_ref) begin
        valid_testFailure <= 1'b1;
        $display("ERROR in valid at time %t : Expected '%h' Actual '%h'", $time, valid_ref, valid);
      end
    end
  end

  assign isTestFailed = valid_testFailure | (end_rsvd_testFailure | (DataOut_testFailure | start_testFailure));



always @(posedge clk)
  begin : completed_msg
    if (snkDone == 1'b1) begin
      if (isTestFailed == 1'b0) begin
        $display("**************TEST COMPLETED (PASSED)**************");
      end
      else begin
        $display("**************TEST COMPLETED (FAILED)**************");
      end
    end
  end

endmodule  // Source_dpi_tb

