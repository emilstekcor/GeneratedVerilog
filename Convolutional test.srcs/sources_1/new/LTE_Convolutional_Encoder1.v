// -------------------------------------------------------------
// 
// File Name: hdl_prj\hdlsrc\commrshdl\LTE_Convolutional_Encoder1.v
// Created: 2024-04-11 04:03:31
// 
// Generated by MATLAB 23.2, HDL Coder 23.2, and Simulink 23.2
// 
// -------------------------------------------------------------


// -------------------------------------------------------------
// 
// Module: LTE_Convolutional_Encoder1
// Source Path: commrshdl/conv subsystem/LTE Convolutional Encoder1
// Hierarchy Level: 1
// Model version: 9.74
// 
// -------------------------------------------------------------

`timescale 1 ns / 1 ns

module LTE_Convolutional_Encoder1
          (clk,
           reset_x,
           enb,
           dataIn,
           ctrlIn_start,
           ctrlIn_end,
           ctrlIn_valid,
           dataOut_0,
           dataOut_1,
           dataOut_2,
           ctrlOut_start,
           ctrlOut_end,
           ctrlOut_valid);


  input   clk;
  input   reset_x;
  input   enb;
  input   signed [3:0] dataIn;  // sfix4_E14
  input   ctrlIn_start;
  input   ctrlIn_end;
  input   ctrlIn_valid;
  output  dataOut_0;  // boolean
  output  dataOut_1;  // boolean
  output  dataOut_2;  // boolean
  output  ctrlOut_start;
  output  ctrlOut_end;
  output  ctrlOut_valid;


  wire start;
  wire end_rsvd;
  wire valid;
  wire signed [3:0] dataOut;  // sfix4_E14
  wire [9:0] ramAddr;  // ufix10
  wire ramWrEn;
  wire startOut;
  wire endOut;
  wire validOut;
  reg  Delay7_out1;
  reg  Delay4_out1;
  wire Constant_out1;
  wire [2:0] Constant_out1_scalarexpand;  // boolean [3]
  reg signed [3:0] Delay2_out1;  // sfix4_E14
  wire signed [3:0] Single_Port_RAM_out1;  // sfix4_E14
  wire signed [3:0] Switch_out1;  // sfix4_E14
  reg signed [3:0] Delay1_out1;  // sfix4_E14
  wire Logical_Operator_out1;
  reg  Delay3_out1;
  wire dataOut_0_1;  // ufix1
  wire dataOut_1_1;  // ufix1
  wire dataOut_2_1;  // ufix1
  wire [2:0] dataOut_3;  // ufix1 [3]
  wire [2:0] Switch1_out1;  // boolean [3]
  reg  [2:0] Delay_out1;  // boolean [3]
  reg  [2:0] alpha_reg;  // ufix1 [3]
  wire Delay6_out1_start;
  reg  [2:0] alpha_reg_1;  // ufix1 [3]
  wire Delay6_out1_end;
  reg  [2:0] alpha_reg_2;  // ufix1 [3]
  wire Delay6_out1_valid;


  assign start = ctrlIn_start;

  assign end_rsvd = ctrlIn_end;

  assign valid = ctrlIn_valid;

  Controller u_Controller (.clk(clk),
                           .reset_x(reset_x),
                           .enb(enb),
                           .dataIn(dataIn),  // sfix4_E14
                           .startIn(start),
                           .endIn(end_rsvd),
                           .validIn(valid),
                           .dataOut(dataOut),  // sfix4_E14
                           .ramAddr(ramAddr),  // ufix10
                           .ramWrEn(ramWrEn),
                           .startOut(startOut),
                           .endOut(endOut),
                           .validOut(validOut)
                           );

  always @(posedge clk)
    begin : Delay7_process
      if (reset_x == 1'b1) begin
        Delay7_out1 <= 1'b0;
      end
      else begin
        if (enb) begin
          Delay7_out1 <= validOut;
        end
      end
    end



  always @(posedge clk)
    begin : Delay4_process
      if (reset_x == 1'b1) begin
        Delay4_out1 <= 1'b0;
      end
      else begin
        if (enb) begin
          Delay4_out1 <= Delay7_out1;
        end
      end
    end



  assign Constant_out1 = 1'b0;



  assign Constant_out1_scalarexpand[0] = Constant_out1;
  assign Constant_out1_scalarexpand[1] = Constant_out1;
  assign Constant_out1_scalarexpand[2] = Constant_out1;

  always @(posedge clk)
    begin : Delay2_process
      if (reset_x == 1'b1) begin
        Delay2_out1 <= 4'sb0000;
      end
      else begin
        if (enb) begin
          Delay2_out1 <= dataOut;
        end
      end
    end



  SinglePortRAM_generic #(.AddrWidth(10),
                          .DataWidth(4)
                          )
                        u_Single_Port_RAM (.clk(clk),
                                           .enb(enb),
                                           .din(Delay2_out1),
                                           .addr(ramAddr),
                                           .we(ramWrEn),
                                           .dout(Single_Port_RAM_out1)
                                           );

  assign Switch_out1 = (Delay7_out1 == 1'b0 ? Delay2_out1 :
              Single_Port_RAM_out1);



  always @(posedge clk)
    begin : Delay1_process
      if (reset_x == 1'b1) begin
        Delay1_out1 <= 4'sb0000;
      end
      else begin
        if (enb) begin
          Delay1_out1 <= Switch_out1;
        end
      end
    end



  assign Logical_Operator_out1 = ramWrEn | Delay7_out1;



  always @(posedge clk)
    begin : Delay3_process
      if (reset_x == 1'b1) begin
        Delay3_out1 <= 1'b0;
      end
      else begin
        if (enb) begin
          Delay3_out1 <= Logical_Operator_out1;
        end
      end
    end



  GeneratorMatrix u_GeneratorMatrix (.clk(clk),
                                     .reset_x(reset_x),
                                     .enb(enb),
                                     .dataIn(Delay1_out1),  // sfix4_E14
                                     .en(Delay3_out1),
                                     .dataOut_0(dataOut_0_1),  // ufix1
                                     .dataOut_1(dataOut_1_1),  // ufix1
                                     .dataOut_2(dataOut_2_1)  // ufix1
                                     );

  assign dataOut_3[0] = dataOut_0_1;
  assign dataOut_3[1] = dataOut_1_1;
  assign dataOut_3[2] = dataOut_2_1;

  assign Switch1_out1 = (Delay4_out1 == 1'b0 ? Constant_out1_scalarexpand :
              dataOut_3);



  always @(posedge clk)
    begin : Delay_process
      if (reset_x == 1'b1) begin
        Delay_out1 <= {3{1'b0}};
      end
      else begin
        if (enb) begin
          Delay_out1 <= Switch1_out1;
        end
      end
    end



  assign dataOut_0 = Delay_out1[0];

  assign dataOut_1 = Delay_out1[1];

  assign dataOut_2 = Delay_out1[2];

  always @(posedge clk)
    begin : c_process
      if (reset_x == 1'b1) begin
        alpha_reg <= {3{1'b0}};
      end
      else begin
        if (enb) begin
          alpha_reg[0] <= startOut;
          alpha_reg[32'sd2:32'sd1] <= alpha_reg[32'sd1:32'sd0];
        end
      end
    end

  assign Delay6_out1_start = alpha_reg[2];



  assign ctrlOut_start = Delay6_out1_start;

  always @(posedge clk)
    begin : c_1_process
      if (reset_x == 1'b1) begin
        alpha_reg_1 <= {3{1'b0}};
      end
      else begin
        if (enb) begin
          alpha_reg_1[0] <= endOut;
          alpha_reg_1[32'sd2:32'sd1] <= alpha_reg_1[32'sd1:32'sd0];
        end
      end
    end

  assign Delay6_out1_end = alpha_reg_1[2];



  assign ctrlOut_end = Delay6_out1_end;

  always @(posedge clk)
    begin : c_2_process
      if (reset_x == 1'b1) begin
        alpha_reg_2 <= {3{1'b0}};
      end
      else begin
        if (enb) begin
          alpha_reg_2[0] <= validOut;
          alpha_reg_2[32'sd2:32'sd1] <= alpha_reg_2[32'sd1:32'sd0];
        end
      end
    end

  assign Delay6_out1_valid = alpha_reg_2[2];



  assign ctrlOut_valid = Delay6_out1_valid;

endmodule  // LTE_Convolutional_Encoder1

